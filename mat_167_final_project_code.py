# -*- coding: utf-8 -*-
"""mat 167 final project code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KXmePGME1ePQq9fYtlnGV5lhCihLH-fL

Priyanshi Singh

921361569



Candice Chan

920841239

Part (a): Load and display the first 16 digit images
"""

from google.colab import files
uploaded = files.upload()

from scipy import io
# Load USPS dataset from .mat file
data_dict = io.loadmat('usps_images.mat')
digits_images = data_dict['digits_images'] # Shape: (256, 9298)
digits_labels = data_dict['digits_labels'] # Shape: (10, 9298), one-hot encoded

import numpy as np
import matplotlib.pyplot as plt
# Display the first 16 digit images in a 4x4 grid
fig, axes = plt.subplots(4, 4)
for i in range(4):
    for j in range(4):
        k = i*4 + j
        # Each digit image is reshaped from 256 to 16x16
        axes[i, j].imshow(np.reshape(digits_images[:, k], (16, 16)), cmap='gray')
        axes[i, j].axis('off')
plt.show()

"""Part (b): Compute and display the 10 mean digit images"""

# Initialize matrix to store the mean digit for each class (0 through 9)
digits_aves = np.zeros((256, 10))

# For each digit j, average all digit images where label==1
for j in range(10):
    digits_aves[:, j] = np.mean(digits_images[:, digits_labels[j, :]==1], axis=1)

# Display the 10 mean digit images in a 2x5 grid
fig, axes = plt.subplots(2, 5)
for i in range(2):
    for j in range(5):
        k = i*5 + j
        axes[i, j].imshow(np.reshape(digits_aves[:, k], (16, 16)), cmap='gray')
        axes[i, j].axis('off')
plt.show()

"""Part (c): K-means clustering on raw digit images

(c.1) Run K-means with 10 clusters using digit_aves.T as the initial centers
"""

from sklearn.cluster import KMeans
kmeans = KMeans(n_clusters=10, random_state=42, init=digits_aves.T)
predictions = kmeans.fit_predict(digits_images.T) # Shape: (9298,)

"""(c.2) Compute the center of each cluster based on the predicted labels"""

cluster_centers = np.zeros((256, 10))
for j in range(10):
    cluster_centers[:, j] = np.mean(digits_images[:, predictions==j], axis=1)

"""(c.3) Compute the confusion matrix and overall classification rate"""

test_confusion = np.zeros((10, 10))

# Fill test_confusion[i, j] = number of digit i predicted as digit j
for i in range(9298):
    true_digit = np.where(digits_labels[:, i]==1)[0][0]
    predicted_cluster = predictions[i]
    test_confusion[true_digit, predicted_cluster] += 1

print('Confusion Matrix:')
# Convert matrix entries into integers
print(test_confusion.astype(int))

# Compute classification rate = correctly predicted digit images / total images
correct_predictions = 0
for i in range(10):
    correct_predictions += test_confusion[i, i]
overall_rate = correct_predictions / 9298
print(f'Overall classification rate: {overall_rate:.4f}')

"""Part (d): PCA as a dimension reduction technique before clustering

(d.1) Center the digit images and compute rank-k SVD
"""

# Compute the mean of all digit images (size: 256 x 1)
mean_all_digits = np.mean(digits_images, axis=1)

# Display the mean digit image
plt.imshow(np.reshape(mean_all_digits, (16, 16)), cmap='gray')
plt.axis('off')
plt.title('Mean of All Digits')
plt.show()

# Subtract the mean from all digit images to create the centered images
digits_images_centered = digits_images - np.tile(mean_all_digits.reshape(-1, 1), (1, 9298))

# Compute and display the 10 mean digit images after centering
digits_aves_centered = np.zeros((256, 10))
for j in range(10):
    digit_mask = digits_labels[j, :]==1
    digits_aves_centered[:, j] = np.mean(digits_images_centered[:, digit_mask], axis=1)

# Display centered class-wise mean digit images
fig, axes = plt.subplots(2, 5, figsize=(10, 4))
for i in range(2):
    for j in range(5):
        digit_idx = i*5 + j
        axes[i, j].imshow(np.reshape(digits_aves_centered[:, digit_idx], (16, 16)), cmap='gray')
        axes[i, j].set_title(f'Mean Centered Digit {digit_idx}')
        axes[i, j].axis('off')
plt.tight_layout()
plt.show()

# Compute the rank-k SVD of the centered images with k=30
from scipy.sparse.linalg import svds
Uk, _, _ = svds(digits_images_centered, k=30) # Size: 256 x 30

"""(d.2) Compute expansion coefficients in PCA basis"""

# Project each centered image onto the top k=30 left singular vectors
digits_svd = Uk.T @ digits_images_centered # Size: 30 x 9298